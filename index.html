<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI Open Mouth (Mobile Fix)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; background-color: black; overflow: hidden; font-family: 'Suit', sans-serif; }
        
        /* ì»¨í…Œì´ë„ˆ */
        .container { position: relative; width: 100vw; height: 100vh; }

        /* ë¹„ë””ì˜¤ì™€ ìº”ë²„ìŠ¤ë¥¼ ì™„ë²½í•˜ê²Œ ê²¹ì¹˜ê¸° ìœ„í•œ ìŠ¤íƒ€ì¼ */
        video, canvas { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            object-fit: cover; /* í™”ë©´ ê½‰ ì±„ìš°ê¸° */
            transform: scaleX(-1); /* ê±°ìš¸ ëª¨ë“œ */
        }
        
        video { z-index: 0; }
        canvas { z-index: 1; }

        /* UI íŒ¨ë„ */
        #ui-panel {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            width: 90%; z-index: 10; text-align: center;
        }

        .status-box {
            background: rgba(0, 0, 0, 0.6); 
            padding: 15px; border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(4px);
        }

        #main-msg { font-size: 1.4rem; font-weight: 800; color: white; display: block; margin-bottom: 5px; text-shadow: 0 2px 4px black;}
        
        .metrics { display: flex; justify-content: space-between; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px; margin-top: 8px;}
        .metric-col { width: 33%; }
        .metric-val { font-size: 1.1rem; font-weight: bold; color: white; display: block; }
        .metric-label { font-size: 0.75rem; color: #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <div id="ui-panel">
            <div class="status-box" id="status-bg">
                <span id="main-msg">ì‹œìŠ¤í…œ ì‹œì‘ ì¤‘...</span>
                <div class="metrics">
                    <div class="metric-col"><span class="metric-label">ì… ë²Œë¦¼</span><br><span class="metric-val" id="val-mouth">-</span></div>
                    <div class="metric-col"><span class="metric-label">ìˆ™ì„(Pitch)</span><br><span class="metric-val" id="val-pitch">-</span></div>
                    <div class="metric-col"><span class="metric-label">íšŒì „(Yaw)</span><br><span class="metric-val" id="val-yaw">-</span></div>
                </div>
            </div>
        </div>

        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script type="module">
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const ctx = canvasElement.getContext('2d');
        
        const mainMsg = document.getElementById('main-msg');
        const statusBg = document.getElementById('status-bg');
        const valMouth = document.getElementById('val-mouth');
        const valPitch = document.getElementById('val-pitch');
        const valYaw = document.getElementById('val-yaw');

        function onResults(results) {
            // [ëª¨ë°”ì¼ í•µì‹¬ 1] ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ í˜„ì¬ ë¸Œë¼ìš°ì € í¬ê¸°ë¡œ ë§¤ í”„ë ˆì„ ê°•ì œ ë™ê¸°í™”
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // ì–¼êµ´ ë¯¸ê²€ì¶œ ì‹œ
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                mainMsg.innerText = "ì–¼êµ´ ì°¾ëŠ” ì¤‘...";
                mainMsg.style.color = "yellow";
                statusBg.style.borderColor = "yellow";
                return;
            }

            const landmarks = results.multiFaceLandmarks[0];

            // [ëª¨ë°”ì¼ í•µì‹¬ 2] ì¢Œí‘œ ë³€í™˜ í•¨ìˆ˜ (0~1 ê°’ì„ í˜„ì¬ ìº”ë²„ìŠ¤ í”½ì…€ë¡œ ë³€í™˜)
            const toPixel = (idx) => {
                return { 
                    x: landmarks[idx].x * canvasElement.width, 
                    y: landmarks[idx].y * canvasElement.height 
                };
            };
            
            // ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜
            const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);

            // --- ë°ì´í„° ê³„ì‚° (NaN ë°©ì§€ ë¡œì§ í¬í•¨) ---
            const p_top = toPixel(10); const p_bottom = toPixel(152);
            const p_ulip = toPixel(13); const p_llip = toPixel(14);
            const p_nose = toPixel(1);
            const p_lear = toPixel(234); const p_rear = toPixel(454);

            // 1. ì… ë²Œë¦¼ (Mouth Ratio)
            const faceHeight = dist(p_top, p_bottom) || 1; // 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€
            const mouthRatio = (dist(p_ulip, p_llip) / faceHeight) * 100;

            // 2. íšŒì „ (Yaw)
            const d_left = dist(p_nose, p_lear);
            const d_right = dist(p_nose, p_rear) || 1;
            const yawRatio = d_left / d_right;
            
            // 3. ìˆ™ì„ê° (Pitch) - ìƒëŒ€ ì¢Œí‘œ(0.0~1.0) ì‚¬ìš©ìœ¼ë¡œ í•´ìƒë„ ë¬´ê´€í•˜ê²Œ ê³„ì‚°
            const noseY = landmarks[1].y;
            const earsY = (landmarks[234].y + landmarks[454].y) / 2;
            const pitchDiff = (noseY - earsY) * 100;

            // --- íŒë… ê¸°ì¤€ ---
            const TH_MOUTH = 7.0; 
            const YAW_MIN = 0.6; const YAW_MAX = 1.4;
            const PITCH_MIN = 3.0; const PITCH_MAX = 15.0; // ì½”ê°€ ê·€ë³´ë‹¤ ì•½ê°„ ì•„ë˜ì— ìˆì–´ì•¼ í•¨

            // --- ìƒíƒœ íŒë‹¨ ---
            let isReady = false;
            let msg = "";
            
            if (yawRatio < YAW_MIN) msg = "ê³ ê°œë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ğŸ‘‰";
            else if (yawRatio > YAW_MAX) msg = "ğŸ‘ˆ ê³ ê°œë¥¼ ì™¼ìª½ìœ¼ë¡œ";
            else if (pitchDiff < PITCH_MIN) msg = "í„±ì„ ë‹¹ê¸°ì„¸ìš” â†“";
            else if (pitchDiff > PITCH_MAX) msg = "í„±ì„ ë“œì„¸ìš” â†‘";
            else if (mouthRatio < TH_MOUTH) msg = "ì…ì„ ë” í¬ê²Œ 'ì•„~' ğŸ˜®";
            else {
                isReady = true;
                msg = "ì´¬ì˜ ê°€ëŠ¥ (READY)";
            }

            // --- UI ì—…ë°ì´íŠ¸ ---
            let color = isReady ? "#00FF00" : "#FF0055"; // ì´ˆë¡ vs í•«í•‘í¬
            
            mainMsg.innerText = msg;
            mainMsg.style.color = color;
            statusBg.style.borderColor = color;

            valMouth.innerText = mouthRatio.toFixed(1);
            valPitch.innerText = pitchDiff.toFixed(1);
            valYaw.innerText = yawRatio.toFixed(2);

            // ìˆ˜ì¹˜ë³„ ìƒ‰ìƒ (ì¡°ê±´ ë¶ˆë§Œì¡± ì‹œ ë¹¨ê°„ìƒ‰)
            valMouth.style.color = (mouthRatio < TH_MOUTH) ? "red" : "#00FF00";
            valYaw.style.color = (yawRatio < YAW_MIN || yawRatio > YAW_MAX) ? "red" : "#00FF00";
            valPitch.style.color = (pitchDiff < PITCH_MIN || pitchDiff > PITCH_MAX) ? "red" : "#00FF00";


            // --- [ì‹œê°í™”] ì„ ì„ ì•„ì£¼ ë‘ê»ê²Œ ê·¸ë¦¼ (ëª¨ë°”ì¼ì—ì„œ ì˜ ë³´ì´ê²Œ) ---
            ctx.lineWidth = 4; 
            ctx.lineCap = "round";
            ctx.strokeStyle = color;
            ctx.fillStyle = color;

            // 1. ì‹­ìì„  (Alignment Crosshair)
            ctx.beginPath();
            ctx.moveTo(p_top.x, p_top.y); ctx.lineTo(p_bottom.x, p_bottom.y); // ì„¸ë¡œ
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(p_lear.x, p_lear.y); ctx.lineTo(p_rear.x, p_rear.y); // ê°€ë¡œ(ê·€-ê·€)
            ctx.stroke();

            // 2. ì½” (ì¤‘ì‹¬ì )
            ctx.beginPath();
            ctx.arc(p_nose.x, p_nose.y, 8, 0, 2*Math.PI);
            ctx.fill();

            // 3. ì…ìˆ  í¬ì¸íŠ¸
            ctx.fillStyle = "yellow";
            ctx.beginPath(); ctx.arc(p_ulip.x, p_ulip.y, 4, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(p_llip.x, p_llip.y, 4, 0, 2*Math.PI); ctx.fill();
        }

        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults(onResults);

        // [ëª¨ë°”ì¼ í•µì‹¬ 3] ì¹´ë©”ë¼ í•´ìƒë„ë¥¼ ê³ ì •í•˜ì§€ ì•Šê³  'ideal'ë¡œ ìš”ì²­
        // width: 1280 ê°™ì€ ê°•ì œ ì„¤ì •ì„ ë¹¼ì•¼ ëª¨ë°”ì¼ ì„¸ë¡œ ëª¨ë“œì—ì„œ ì •ìƒ ì‘ë™í•¨
        const camera = new Camera(videoElement, {
            onFrame: async () => { await faceMesh.send({image: videoElement}); },
            width: { ideal: 1280 }, // ê°•ì œê°€ ì•„ë‹Œ ê¶Œì¥ ì‚¬í•­ìœ¼ë¡œ ë³€ê²½
            height: { ideal: 720 },
            facingMode: "user" // ì „ë©´ ì¹´ë©”ë¼ ìš°ì„ 
        });
        camera.start();
    </script>
</body>
</html>
